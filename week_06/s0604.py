# Гражданская оборона
'''
Штаб гражданской обороны Тридесятой области решил обновить план спасения на
случай ядерной атаки. Известно, что все n селений Тридесятой области находятся
вдоль одной прямой дороги. Вдоль дороги также расположены m бомбоубежищ, в
которых жители селений могут укрыться на случай ядерной атаки.

Чтобы спасение в случае ядерной тревоги проходило как можно эффективнее,
необходимо для каждого селения определить ближайшее к нему бомбоубежище.

Формат ввода

В первой строке вводится число n - количество селений (1 <= n <= 100000).
Вторая строка содержит n различных целых чисел, i-е из этих чисел задает
расстояние от начала дороги до i-го селения.
В третьей строке входных данных задается число m - количество бомбоубежищ
(1 <= m <= 100000).
Четвертая строка содержит m различных целых чисел, i-е из этих чисел задает
расстояние от начала дороги до i-го бомбоубежища. Все расстояния положительны
и не превышают 10⁹. Селение и убежище могут располагаться в одной точке.

Формат вывода

Выведите n чисел - для каждого селения выведите номер ближайшего к нему
бомбоубежища. Бомбоубежища пронумерованы от 1 до m в том порядке,
в котором они заданы во входных данных.

Указание

Создайте список кортежей из пар (позиция селения, его номер в исходном списке),
а также аналогичный список для бомбоубежищ. Отсортируйте эти списки.

Перебирайте селения в порядке возрастания.

Для селения ближайшими могут быть два соседних бомбоубежища, среди них надо
выбрать ближайшее. При переходе к следующему селению не обязательно искать
ближайшее бомбоубежище с самого начала. Его можно искать начиная с позиции,
найденной для предыдущего города. Аналогично, не нужно искать подходящее
бомбоубежище до конца списка бомбоубежищ: достаточно найти самое близкое.
Если Вы неэффективно реализуете эту часть, то решение тесты не пройдет.

Для хранения ответа используйте список, где индекс будет номером селения,
а по этому индексу будет запоминаться номер бомбоубежища.
'''
'''
n = 10
n_dist = [79, 64, 13, 8, 38, 29, 58, 20, 56, 17]
n_list = []
for i in range(n):
    n_list.append((n_dist[i], i + 1))
n_sort_list = sorted(n_list)

m = 10
m_dist = [53, 19, 20, 85, 82, 39, 58, 46, 51, 69]
m_list = []
for i in range(m):
    m_list.append((m_dist[i], i + 1))
m_sort_list = sorted(m_list)
'''
'''
n = int(input())
n_dist = list(map(int, input().split()))
n_list = []
for i in range(n):
    n_list.append((n_dist[i], i + 1))
n_sort_list = sorted(n_list)

m = int(input())
m_dist = list(map(int, input().split()))
m_list = []
for i in range(m):
    m_list.append((m_dist[i], i + 1))
m_sort_list = sorted(m_list)
'''

n = 4
n_dist = [1, 2, 6, 10]
n_list = []
for i in range(n):
    n_list.append((n_dist[i], i + 1))
n_sort_list = sorted(n_list)
print(n_sort_list)

m = 2
m_dist = [7, 3]
m_list = []
for i in range(m):
    m_list.append((m_dist[i], i + 1))
m_sort_list = sorted(m_list)
print(m_sort_list)

saved_index = 0
i = 0
n_m_list = []
for i in range(n):
    print('i=', i)
    print('saved index=', saved_index)
    for j in range(saved_index, m-1):
        print('j0= ', j)
        distance_i_j = abs(n_sort_list[i][0] - m_sort_list[j][0])
        print(distance_i_j)
        distance_i_j1 = abs(n_sort_list[i][0] - m_sort_list[j+1][0])
        print(distance_i_j1)
        if distance_i_j <= distance_i_j1:
            saved_index = j
            break
        else:
            print('j= ', j)
            if j + 2 == m:
                j += 1
                saved_index += 1
                break
            else:
                saved_index += 1
    new_point = (n_sort_list[i][1], m_sort_list[j][1])
    n_m_list.append(new_point)
    print(n_m_list)
n_m_list_sort = sorted(n_m_list)
final_list = []
for i in range(n):
    final_list.append(n_m_list_sort[i][1])
print(*final_list)
